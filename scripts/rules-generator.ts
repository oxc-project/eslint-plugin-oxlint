import { writeFile } from 'node:fs/promises';
import path from 'node:path';
import type { Rule } from './traverse-rules.js';
import { camelCase } from 'scule';
import { typescriptTypeAwareRules } from './constants.js';

export enum RulesGrouping {
  CATEGORY = 'category',
  SCOPE = 'scope',
}

export type ResultMap = Map<string, string[]>;

export class RulesGenerator {
  private rulesGrouping: RulesGrouping;
  private rulesArray: Rule[];
  constructor(rulesArray: Rule[] = [], rulesGrouping: RulesGrouping = RulesGrouping.SCOPE) {
    this.rulesArray = rulesArray;
    this.rulesGrouping = rulesGrouping;
  }

  public setRulesGrouping(rulesGrouping: RulesGrouping) {
    this.rulesGrouping = rulesGrouping;
  }

  private groupItemsBy(rules: Rule[], rulesGrouping: RulesGrouping): Map<string, string[]> {
    const map = new Map<string, string[]>();
    for (const item of rules) {
      const key = item[rulesGrouping];
      const group = map.get(key) || [];
      group.push(item.value);
      map.set(key, group);
    }

    return map;
  }

  public generateRulesCode() {
    console.log(`Generating rules, grouped by ${this.rulesGrouping}`);

    const rulesGrouping = this.rulesGrouping;
    // Filter out nursery rules when grouping by scope
    const rulesArray =
      this.rulesGrouping === RulesGrouping.SCOPE
        ? this.rulesArray.filter((rule) => rule.category !== 'nursery')
        : this.rulesArray;

    const rulesMap = this.groupItemsBy(rulesArray, rulesGrouping);

    const exportGrouping: string[] = [];
    let code = '// These rules are automatically generated by scripts/generate-rules.ts\n\n';

    // Generate type-aware rules map ONLY for category grouping
    if (this.rulesGrouping === RulesGrouping.CATEGORY) {
      code += '// TypeScript type-aware rules that can be filtered at runtime\n';
      code += 'const typeAwareRules: Record<string, "off"> = {\n';

      // Find all typescript rules that are type-aware
      // Note: rule.value already has the @typescript-eslint/ prefix at this point
      const tsRules = this.rulesArray.filter((rule) => {
        if (rule.scope !== 'typescript') return false;
        // Extract the base name by removing the @typescript-eslint/ prefix
        const baseName = rule.value.replace(/^@typescript-eslint\//, '');
        return typescriptTypeAwareRules.includes(baseName);
      });

      code += tsRules.map((rule) => `  '${rule.value.replaceAll('_', '-')}': "off"`).join(',\n');
      code += '\n};\n\n';
    }

    for (const grouping of rulesMap.keys()) {
      exportGrouping.push(grouping);
      const rules = rulesMap.get(grouping);

      code += `const ${camelCase(grouping)}Rules: Record<string, "off"> = {\n`;

      code += rules
        ?.map((rule) => {
          return `  '${rule.replaceAll('_', '-')}': "off"`;
        })
        .join(',\n');
      code += '\n};\n\n';
    }

    code += 'export {\n';
    code += exportGrouping
      .map((grouping) => {
        return `  ${grouping.replaceAll(/_(\w)/g, (_, c) => c.toUpperCase())}Rules`;
      })
      .join(',\n');

    // Add typeAwareRules to exports for CATEGORY grouping
    if (this.rulesGrouping === RulesGrouping.CATEGORY) {
      code += ',\n  typeAwareRules';
    }

    code += '\n}';

    return code;
  }

  public generateRules(folderPath: string): Promise<void> {
    const output = this.generateRulesCode();

    return writeFile(path.resolve(folderPath, `rules-by-${this.rulesGrouping}.ts`), output);
  }
}
