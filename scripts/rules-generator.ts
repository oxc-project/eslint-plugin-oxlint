import { writeFile } from 'node:fs/promises';
import path from 'node:path';
import type { Rule } from './traverse-rules.js';
import { camelCase } from 'scule';
import { typeAwareRulesSet } from './constants.js';

export enum RulesGrouping {
  CATEGORY = 'category',
  SCOPE = 'scope',
}

export type ResultMap = Map<string, string[]>;

export class RulesGenerator {
  private rulesGrouping: RulesGrouping;
  private rulesArray: Rule[];
  constructor(rulesArray: Rule[] = [], rulesGrouping: RulesGrouping = RulesGrouping.SCOPE) {
    this.rulesArray = rulesArray;
    this.rulesGrouping = rulesGrouping;
  }

  public setRulesGrouping(rulesGrouping: RulesGrouping) {
    this.rulesGrouping = rulesGrouping;
  }

  private groupItemsBy(rules: Rule[], rulesGrouping: RulesGrouping): Map<string, string[]> {
    const map = new Map<string, string[]>();
    for (const item of rules) {
      const key = item[rulesGrouping];
      const group = map.get(key) || [];
      group.push(item.value);
      map.set(key, group);
    }

    // Ensure that the rules in each group are unique.
    for (const [key, group] of map.entries()) {
      map.set(key, [...new Set(group)]);
    }

    return map;
  }

  private splitIntoTypeAwareAndNonTypeAwareRules(rules: Rule[]): {
    typeAwareRules: Rule[];
    nonTypeAwareRules: Rule[];
  } {
    const typeAwareRules: Rule[] = [];
    const nonTypeAwareRules: Rule[] = [];

    for (const rule of rules) {
      if (rule.scope === 'typescript' && typeAwareRulesSet.has(rule.value)) {
        typeAwareRules.push(rule);
      } else {
        nonTypeAwareRules.push(rule);
      }
    }

    return { typeAwareRules, nonTypeAwareRules };
  }

  public generateRulesCode() {
    console.log(`Generating rules, grouped by ${this.rulesGrouping}`);

    const rulesGrouping = this.rulesGrouping;
    // Filter out nursery rules when grouping by scope
    const rulesArray =
      this.rulesGrouping === RulesGrouping.SCOPE
        ? this.rulesArray.filter((rule) => rule.category !== 'nursery')
        : this.rulesArray;

    // Split into type-aware and non-type-aware rules
    const { typeAwareRules, nonTypeAwareRules } =
      this.splitIntoTypeAwareAndNonTypeAwareRules(rulesArray);

    let code = '// These rules are automatically generated by scripts/generate-rules.ts\n\n';
    const exports: string[] = [];

    for (const { rules, suffix } of [
      { rules: nonTypeAwareRules, suffix: '' },
      { rules: typeAwareRules, suffix: 'TypeAware' },
    ]) {
      const rulesMap = this.groupItemsBy(rules, rulesGrouping);

      for (const [grouping, groupRules] of rulesMap.entries()) {
        const jsVariableName = camelCase(grouping) + suffix + 'Rules';

        exports.push(jsVariableName);
        code += `const ${jsVariableName}: Record<string, "off"> = {\n`;

        code += groupRules
          .map((rule) => {
            return `  '${rule.replaceAll('_', '-')}': "off"`;
          })
          .join(',\n');
        code += '\n};\n\n';
      }
    }

    code += 'export {\n';
    code += exports
      .map((grouping) => {
        return `  ${grouping}`;
      })
      .join(',\n');
    code += '\n}';

    return code;
  }

  public generateRules(folderPath: string): Promise<void> {
    const output = this.generateRulesCode();

    return writeFile(path.resolve(folderPath, `rules-by-${this.rulesGrouping}.ts`), output);
  }
}
